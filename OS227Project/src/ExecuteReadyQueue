import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Comparator;

public class ExecuteReadyQueue {
    private Queue<PCB> readyQueue;
    private int quantum; // الوقت المخصص لكل عملية في Round-Robin

    public ExecuteReadyQueue(Queue<PCB> readyQueue, int quantum) {
        this.readyQueue = readyQueue;
        this.quantum = quantum;
    }

    // First-Come-First-Serve (FCFS) Scheduling
    public void fcfsSchedule() {
        int currentTime = 0;

        while (!readyQueue.isEmpty()) {
            PCB process = readyQueue.poll(); //peak instaed of poll
            process.setState("RUNNING");
            System.out.println("Executing Process " + process.id + " with Burst Time: " + process.burstTime);

            try {
                Thread.sleep(process.burstTime);
            } catch (InterruptedException e) {
                System.out.println("Process " + process.id + " execution interrupted.");
            }

            currentTime += process.burstTime;
            process.setState("TERMINATED");
            SystemCalls.updateJobTimes(process, currentTime);
            SystemCalls.releaseMemory(process, readyQueue,Main.availableMemory); // تحرير الذاكرة بعد التنفيذ
        }

        System.out.println("FCFS Scheduling completed.");
    }

    // Shortest Job First (SJF) Scheduling
    public void sjfSchedule() {
        int currentTime = 0;

        // ترتيب العمليات بناءً على أقل Burst Time باستخدام PriorityQueue
        PriorityQueue<PCB> sjfQueue = new PriorityQueue<>(Comparator.comparingInt(p -> p.burstTime));
        sjfQueue.addAll(readyQueue);

        while (!sjfQueue.isEmpty()) {
            PCB process = sjfQueue.poll();
            process.setState("RUNNING");
            System.out.println("Executing Process " + process.id + " with Burst Time: " + process.burstTime);

            try {
                Thread.sleep(process.burstTime);
            } catch (InterruptedException e) {
                System.out.println("Process " + process.id + " execution interrupted.");
            }

            currentTime += process.burstTime;
            process.setState("TERMINATED");
            SystemCalls.updateJobTimes(process, currentTime);
            SystemCalls.releaseMemory(process, readyQueue, Main.availableMemory); // تحرير الذاكرة بعد التنفيذ
        }

        System.out.println("SJF Scheduling completed.");
    }

    // Round-Robin (RR) Scheduling
    public void rrSchedule() {
        int currentTime = 0;

        // تحويل readyQueue إلى LinkedList لدعم Round-Robin
        Queue<PCB> rrQueue = new LinkedList<>(readyQueue);

        while (!rrQueue.isEmpty()) {
            PCB process = rrQueue.poll();
            int timeSlice = Math.min(quantum, process.remainingTime);

            process.setState("RUNNING");
            System.out.println("Executing Process " + process.id + " for Time Slice: " + timeSlice + " ms");

            try {
                Thread.sleep(timeSlice);
            } catch (InterruptedException e) {
                System.out.println("Process " + process.id + " execution interrupted.");
            }

            process.remainingTime -= timeSlice;
            currentTime += timeSlice;

            if (process.remainingTime <= 0) {
                process.setState("TERMINATED");
                SystemCalls.updateJobTimes(process, currentTime);
                SystemCalls.releaseMemory(process, readyQueue, Main.availableMemory); // تحرير الذاكرة عند انتهاء العملية
                System.out.println("Process " + process.id + " completed execution.");
            } else {
                process.setState("WAITING");
                rrQueue.add(process); // إعادة العملية إلى القائمة إذا لم تنتهِ
                System.out.println("Process " + process.id + " paused with Remaining Time: " + process.remainingTime + " ms");
            }
        }

        System.out.println("Round-Robin Scheduling completed.");
    }
}
